<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Design on Embedded Systems Design</title>
    <link>https://embedded-systems-design.github.io/tags/software-design/</link>
    <description>Recent content in Software Design on Embedded Systems Design</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://embedded-systems-design.github.io/tags/software-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Software design</title>
      <link>https://embedded-systems-design.github.io/software-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://embedded-systems-design.github.io/software-design/</guid>
      <description>&lt;h2 id=&#34;what-is-a-finite-state-machine&#34;&gt;What is a finite state machine?&lt;/h2&gt;&#xA;&lt;p&gt;A finite state machine (FSM) is a way of modeling a system such that there are a limited number of finite &amp;ldquo;states&amp;rdquo; that a system can be in, and that it can only be in one of those states at a time. Events (e.g., pushing a button) cause the system to change from one state to the next. Unexpected events do not cause the system to change states, which is useful for ignoring spurious inputs. Rather than coding for every possible input, you can instead code only for inputs that matter at the given time. The following resources provide a solid conceptual framing and implementation examples:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
